<!DOCTYPE html>
<html>
<head>
    <title>MIG Modules</title>
    <meta charset="utf-8" />
    <link href="docstyle.css" rel="stylesheet" />
    <meta content="Julien Vehent &lt;jvehent@mozilla.com&gt;" name="author" />
</head>
<body>
    <h1>MIG Modules</h1>
    <aside class="topic contents" id="table-of-contents">
        <h1>Table of Contents</h1>
        <ul class="auto-toc">
            <li><a href="#module-logic">1   Module logic</a>
                <ul class="auto-toc">
                    <li><a href="#registration">1.1   Registration</a></li>
                    <li><a href="#execution">1.2   Execution</a>
                        <ul class="auto-toc">
                            <li><a href="#runner-interface">1.2.1   Runner Interface</a></li>
                            <li><a href="#parameters">1.2.2   Parameters</a></li>
                            <li><a href="#run">1.2.3   Run</a></li>
                            <li><a href="#validate-parameters">1.2.4   Validate Parameters</a></li>
                        </ul>
                    </li>
                    <li><a href="#results">1.3   Results</a>
                        <ul class="auto-toc">
                            <li><a href="#success">1.3.1   Success</a></li>
                            <li><a href="#foundanything">1.3.2   FoundAnything</a></li>
                            <li><a href="#elements">1.3.3   Elements</a></li>
                            <li><a href="#statistics">1.3.4   Statistics</a></li>
                            <li><a href="#errors">1.3.5   Errors</a></li>
                        </ul>
                    </li>
                    <li><a href="#additional-interfaces">1.4   Additional interfaces</a>
                        <ul class="auto-toc">
                            <li><a href="#hasresultsprinter">1.4.1   HasResultsPrinter</a></li>
                            <li><a href="#hasparamscreator">1.4.2   HasParamsCreator</a></li>
                            <li><a href="#hasparamsparser">1.4.3   HasParamsParser</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="#the-example-module">2   The Example module</a>
                <ul class="auto-toc">
                    <li><a href="#headers-and-structs">2.1   Headers and structs</a></li>
                    <li><a href="#id1">2.2   Validate Parameters</a></li>
                    <li><a href="#id2">2.3   Run</a></li>
                    <li><a href="#doing-work-and-building-results">2.4   Doing work and building results</a></li>
                    <li><a href="#printing-results">2.5   Printing results</a></li>
                    <li><a href="#creating-parameters">2.6   Creating parameters</a></li>
                </ul>
            </li>
        </ul>
    </aside>
    <p>In this document, we explain how modules are written and integrated into MIG.</p>
    <p>The reception of a command by an agent triggers the execution of modules. A module is a Go package that is imported into the agent at compilation, and that performs a very specific set of tasks. For example, the <code>file</code> module provides a way to scan a file system for files that contain regexes, match a checksum, ... Another module is called <code>netstat</code>, and looks for IP addresses currently connected to an endpoint. <code>ping</code> is a module to ping targets from endpoints, etc..</p>
    <p>Module are somewhat autonomous. They can be developped outside of the MIG code base, and only imported during compilation of the agent. Go does not provide a way to load modules dynamically, so modules are compiled into the agent's static binary, and not as separate files.</p>
    <section id="module-logic">
        <h2>1   Module logic</h2>
        <section id="registration">
            <h3>1.1   Registration</h3>
            <p>A module must import <code>mig/modules</code>.</p>
            <p>A module registers itself at runtime via its <code>init()</code> function which must call <code>modules.Register</code> with a module name and an instance implementing <code>modules.Moduler</code>:</p>
            <pre class="code go"><span class="kd">type</span> <span class="nx">Moduler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">NewRun</span><span class="p">()</span> <span class="nx">Runner</span>
<span class="p">}</span></pre>
            <p>A module must have a unique name. A good practice is to use the same name for the module name as for the Go package name. However, it is possible for a single Go package to implement multiple modules, simply by registering different Modulers with different names.</p>
            <p>The sole method of a Moduler creates a new instance to represent a "run" of the module, implementing the <code>modules.Runner</code> interface:</p>
            <pre class="code go"><span class="kd">type</span> <span class="nx">Runner</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Run</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="kt">string</span>
    <span class="nx">ValidateParameters</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span></pre>
            <p>Any run-specific information should be associated with this instance and not with the Moduler or stored in a global variable. It should be possible for multiple runs of the module to execute simultaneously.</p>
            <p>The code sample below shows how the <code>example</code> module uses package name <code>example</code> and registers with name <code>example</code>.</p>
            <pre class="code go"><span class="kn">package</span> <span class="nx">example</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"mig/modules"</span>
<span class="p">)</span>

<span class="c1">// An instance of this type will represent this module; it's possible to add
// additional data fields here, although that is rarely needed.
</span><span class="kd">type</span> <span class="nx">module</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">module</span><span class="p">)</span> <span class="nx">NewRun</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">run</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// init is called by the Go runtime at startup. We use this function to
// register the module in a global array of available modules, so the
// agent knows we exist
</span><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">modules</span><span class="p">.</span><span class="nx">Register</span><span class="p">(</span><span class="s">"example"</span><span class="p">,</span> <span class="nb">new</span><span class="p">(</span><span class="nx">module</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">run</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Parameters</span> <span class="nx">params</span>
    <span class="nx">Results</span>    <span class="nx">modules</span><span class="p">.</span><span class="nx">Result</span>
<span class="p">}</span></pre>
            <p><code>init()</code> is a go builtin function that is executed automatically in all imported packages when a program starts. In the agents, modules are imported anonymously, which means that their <code>init()</code> function will be executed even if the modules are unused in the agent. Therefore, when MIG Agent starts, all modules execute their <code>init()</code> function, add their names and runner function to the global list of available module, and stop there.</p>
            <p>The list of modules imported in the agent is maintained in <code>conf/available_modules.go</code>. You should use this file to add or remove modules.</p>
            <pre class="code go"><span class="kn">import</span> <span class="p">(</span>
    <span class="c1">//_ "mig/modules/example"
</span>    <span class="nx">_</span> <span class="s">"mig/modules/agentdestroy"</span>
    <span class="nx">_</span> <span class="s">"mig/modules/file"</span>
    <span class="nx">_</span> <span class="s">"mig/modules/netstat"</span>
    <span class="nx">_</span> <span class="s">"mig/modules/timedrift"</span>
    <span class="c1">//_ "mig/modules/upgrade"
</span>    <span class="nx">_</span> <span class="s">"mig/modules/ping"</span>
<span class="p">)</span></pre>
        </section>
        <section id="execution">
            <h3>1.2   Execution</h3>
            <p>When the agent receives a command to execute, it looks up modules in the global list <code>modules.Available</code>, and if a module is registered to execute the command, calls its runner function to get a new instance representing the run, and then calls that instance's <code>Run</code> method.</p>
            <section id="runner-interface">
                <h4>1.2.1   Runner Interface</h4>
                <p>A mig module typically defines its own <code>run</code> struct implementing the <code>modules.Runner</code> interface and representing a single run of the module. The <code>run</code> struct typically contains two fields: module parameters and module results. The former is any format the module choses to use, while the latter generally implements the <code>modules.Result</code> struct (note that this is not required, but it is the easiest way to return a properly-formatted JSON result).</p>
                <pre class="code go"><span class="kd">type</span> <span class="nx">run</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Parameters</span> <span class="nx">myModuleParams</span>
    <span class="nx">Results</span>    <span class="nx">modules</span><span class="p">.</span><span class="nx">Result</span>
<span class="p">}</span></pre>
            </section>
            <section id="parameters">
                <h4>1.2.2   Parameters</h4>
                <p>When a module is available to run an operation, the agent passes the operation parameters to the module.</p>
                <p>The easiest way to see this is to invoke the agent binary with the flag <strong>-m</strong>, followed by the name of the module:</p>
                <pre class="code bash"><span class="nv">$ </span>mig-agent -m example <span class="o">&lt;&lt;&lt;</span> <span class="s1">'{"class":"parameters", "parameters":{"gethostname": true, "getaddresses": true, "lookuphost": ["www.google.com"]}}'</span>
<span class="o">[</span>info<span class="o">]</span> using <span class="nb">builtin </span>conf
<span class="o">{</span><span class="s2">"foundanything"</span>:true,<span class="s2">"success"</span>:true,<span class="s2">"elements"</span>:<span class="o">{</span><span class="s2">"hostname"</span>:<span class="s2">"fedbox2.jaffa.linuxwall.info"</span>,<span class="s2">"addresses"</span>:<span class="o">[</span><span class="s2">"172.21.0.3/20"</span>,<span class="s2">"fe80::8e70:5aff:fec8:be50/64"</span><span class="o">]</span>,<span class="s2">"lookeduphost"</span>:<span class="o">{</span><span class="s2">"www.google.com"</span>:<span class="o">[</span><span class="s2">"74.125.196.105"</span>,<span class="s2">"74.125.196.147"</span>,<span class="s2">"74.125.196.106"</span>,<span class="s2">"74.125.196.104"</span>,<span class="s2">"74.125.196.103"</span>,<span class="s2">"74.125.196.99"</span>,<span class="s2">"2607:f8b0:4002:c07::6a"</span><span class="o">]}}</span>,<span class="s2">"statistics"</span>:<span class="o">{</span><span class="s2">"stufffound"</span>:3<span class="o">}</span>,<span class="s2">"errors"</span>:null<span class="o">}</span></pre>
                <p>The module receives this JSON input as an <code>io.Reader</code> passed to its <code>Run</code> method.</p>
            </section>
            <section id="run">
                <h4>1.2.3   Run</h4>
                <p>The module's <code>Run</code> method should start by trying to read parameters from the given <code>in io.Reader</code>. It then validates the parameters against its own formatting rules, performs work and returns results in a JSON string.</p>
                <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">Run</span><span class="p">(</span><span class="nx">in</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Errors</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span> <span class="nx">e</span><span class="p">))</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="nx">buf</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">)</span>
            <span class="nx">out</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">ReadInputParameters</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ValidateParameters</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">doModuleStuff</span><span class="p">()</span>
<span class="p">}</span></pre>
                <p>The <code>defer</code> block in the sample above is used to catch potential panics and return a nicely formatted JSON error to the agent. This is a clean way to indicate to the MIG platform that the module has failed to run on this agent.</p>
            </section>
            <section id="validate-parameters">
                <h4>1.2.4   Validate Parameters</h4>
                <p>A module must implement the <code>ValidateParameters()</code> method.</p>
                <p>The role of that interface is to go through the parameters supplied to <code>Run</code> and verify that they follow a format expected by the module. This method is useful during <code>Run</code> but is not called from outside the module.</p>
                <p>Go is strongly typed, so there's no risk of finding a string when a float is expected. However, this function should verify that values are in a proper range, that regular expressions compile without errors, or that string parameters use the correct syntax.</p>
                <p>When validation fails, an error with a descriptive validation failure must be returned to the caller.</p>
                <p>A good example of validating parameters can be found in the <code>file</code> module at <a href="https://github.com/mozilla/mig/blob/master/src/mig/modules/file/file.go">https://github.com/mozilla/mig/blob/master/src/mig/modules/file/file.go</a></p>
            </section>
        </section>
        <section id="results">
            <h3>1.3   Results</h3>
            <p>Results must follow a specific format defined in <code>modules.Result</code>. Some rules apply to the way fields in this struct must be set.</p>
            <pre class="code go"><span class="kd">type</span> <span class="nx">Result</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Success</span>       <span class="kt">bool</span>        <span class="s">`json:"success"`</span>
    <span class="nx">FoundAnything</span> <span class="kt">bool</span>        <span class="s">`json:"foundanything"`</span>
    <span class="nx">Elements</span>      <span class="kd">interface</span><span class="p">{}</span> <span class="s">`json:"elements"`</span>
    <span class="nx">Statistics</span>    <span class="kd">interface</span><span class="p">{}</span> <span class="s">`json:"statistics"`</span>
    <span class="nx">Errors</span>        <span class="p">[]</span><span class="kt">string</span>    <span class="s">`json:"errors"`</span>
<span class="p">}</span></pre>
            <section id="success">
                <h4>1.3.1   Success</h4>
                <p><code>Success</code> must inform the investigator if the module has failed to complete its execution. It must be set to <code>true</code> only if the module has ran successfully. It does not indicate anything about the results returned by the module, just that it ran and finished.</p>
            </section>
            <section id="foundanything">
                <h4>1.3.2   FoundAnything</h4>
                <p><code>FoundAnything</code> must be set to <code>true</code> only when the module was tasked with finding something, and at least one instance of that something was found. If the module searched for multiple things, one find is enough to set this flag to true. The goal is to indicate to the investigator that the results from this agent need closer scrutiny.</p>
            </section>
            <section id="elements">
                <h4>1.3.3   Elements</h4>
                <p><code>Elements</code> contains raw results from the module. This is defined as an interface, which means that each module must define the format of the results returned to the MIG platform. The only rule here is that <strong>modules must never return raw data to investigators</strong>. Metadata is fine, but file contents or memory dumps are not something MIG should be transporting ever.</p>
            </section>
            <section id="statistics">
                <h4>1.3.4   Statistics</h4>
                <p><code>Statistics</code> is an optional struct that can contain stats about the execution of the module. For example, the <code>file</code> module returns the numbers of files inspected by a given search, as well as the time it took to run the investigation. That information is often useful for investigators.</p>
            </section>
            <section id="errors">
                <h4>1.3.5   Errors</h4>
                <p><code>Errors</code> is an array of string that can contain soft and hard errors. If the module failed to run, <code>Success</code> would be set to <code>false</code> and <code>Errors</code> would contain a single error with the description of the failure. If the module succeeded to run, then <code>Errors</code> could contain soft failures that did not prevent the module from finishing, but may be useful for the investigator to know about. For example, if the <code>memory</code> module fails to inspect a given memory region, the <code>Errors</code> array could contain an entry providing that information.</p>
            </section>
        </section>
        <section id="additional-interfaces">
            <h3>1.4   Additional interfaces</h3>
            <section id="hasresultsprinter">
                <h4>1.4.1   HasResultsPrinter</h4>
                <p><code>HasResultsPrinter</code> is an interface used to allow a module to implement the <strong>PrintResults()</strong> function. <code>PrintResults()</code> is a pretty-printer used to display the results of a module as an array of string. It is defined as a module-specific interface because only the module knows how to parse its <code>Elements</code> and <code>Statistics</code> interfaces in <code>modules.Result</code>.</p>
                <p>The interface is defined as:</p>
                <pre class="code go"><span class="c1">// HasResultsPrinter implements functions used by module to print information
</span><span class="kd">type</span> <span class="nx">HasResultsPrinter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">PrintResults</span><span class="p">(</span><span class="nx">result</span> <span class="nx">Result</span><span class="p">,</span> <span class="nx">showResultsOnly</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></pre>
                <p>A typical implementation of <code>PrintResults</code> takes a <code>modules.Result</code> struct and a boolean that indicates whether the printer should display errors and statistics or only found results. When that boolean is set to <code>true</code>, errors, stats and empty results are <strong>not</strong> displayed. Note that the <code>result</code> argument is the result of unmarhsalling the marhsalled value returned from the <code>Run</code> method.</p>
                <p>The function returns results into an array of strings.</p>
                <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">PrintResults</span><span class="p">(</span><span class="nx">result</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="nx">matchOnly</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">prints</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">el</span>    <span class="nx">elements</span>
        <span class="nx">stats</span> <span class="nx">statistics</span>
    <span class="p">)</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">GetElements</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">el</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="o">...</span> <span class="nx">add</span> <span class="nx">things</span> <span class="nx">into</span> <span class="nx">the</span> <span class="nx">prints</span> <span class="nx">array</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">if</span> <span class="nx">matchOnly</span> <span class="p">{</span>
        <span class="k">return</span> <span class="c1">// stop here
</span>    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
        <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"error: %v"</span><span class="p">,</span> <span class="nx">e</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">GetStatistics</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="o">...</span> <span class="nx">add</span> <span class="nx">stats</span> <span class="nx">into</span> <span class="nx">the</span> <span class="nx">prints</span> <span class="nx">array</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span>
<span class="p">}</span></pre>
            </section>
            <section id="hasparamscreator">
                <h4>1.4.2   HasParamsCreator</h4>
                <p><code>HasParamsCreator</code> implements the <code>ParamsCreator()</code> function used to provide interactive parameters creation in the MIG Console. The function does not take any input value, but implements a terminal prompt for the investigator to fill up the module parameters. The function returns a Parameters structure that the MIG Console will add into an Action.</p>
                <p>It can be implemented in various ways, as long as it prompt the user in the terminal using something like <code>fmt.Scanln()</code>.</p>
                <p>The interface is defined as:</p>
                <pre class="code go"><span class="kd">type</span> <span class="nx">HasParamsCreator</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ParamsCreator</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></pre>
                <p>A module implementation would have the function:</p>
                <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">ParamsCreator</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"initializing netstat parameters creation"</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="kd">var</span> <span class="nx">p</span> <span class="nx">params</span>
    <span class="nx">printHelp</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
    <span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"drift&gt; "</span><span class="p">)</span>
        <span class="nx">scanner</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"Invalid input. Try again"</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">input</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">input</span> <span class="o">==</span> <span class="s">"help"</span> <span class="p">{</span>
            <span class="nx">printHelp</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">input</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">ParseDuration</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"invalid drift duration. try again. ex: drift&gt; 5s"</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">Drift</span> <span class="p">=</span> <span class="nx">input</span>
        <span class="k">break</span>
    <span class="p">}</span>
    <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span> <span class="p">=</span> <span class="nx">p</span>
    <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ValidateParameters</span><span class="p">()</span>
<span class="p">}</span></pre>
                <p>It is highly recommend to call <code>ValidateParameters</code> to verify that the parameters supplied by the users are correct.</p>
            </section>
            <section id="hasparamsparser">
                <h4>1.4.3   HasParamsParser</h4>
                <p><code>HasParamsParser</code> is similar to <code>HasParamsCreator</code>, but implements a command line parameters parser instead of an interactive prompt. It is used by the MIG command line to parse module-specific flags into module Parameters. Each module must implement <code>ParamsParser()</code> to transform an array of string into a parameters interface. The recommended way to implement it is to use <code>FlagSet</code> from the <code>flag</code> Go package. The interface is defined as:</p>
                <pre class="code go"><span class="c1">// HasParamsParser implements a function that parses command line parameters
</span><span class="kd">type</span> <span class="nx">HasParamsParser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ParamsParser</span><span class="p">([]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></pre>
                <p>A typical implementation from the <code>timedrift</code> module looks as follows:</p>
                <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">ParamsParser</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">err</span>   <span class="kt">error</span>
        <span class="nx">drift</span> <span class="kt">string</span>
        <span class="nx">fs</span>    <span class="nx">flag</span><span class="p">.</span><span class="nx">FlagSet</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"help"</span> <span class="p">{</span>
        <span class="nx">printHelp</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"help printed"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="s">"time"</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ContinueOnError</span><span class="p">)</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">drift</span><span class="p">,</span> <span class="s">"drift"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">"see help"</span><span class="p">)</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">ParseDuration</span><span class="p">(</span><span class="nx">drift</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"invalid drift duration. try help."</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">.</span><span class="nx">Drift</span> <span class="p">=</span> <span class="nx">drift</span>
    <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ValidateParameters</span><span class="p">()</span>
<span class="p">}</span></pre>
                <p>It is highly recommend to call <code>ValidateParameters</code> to verify that the parameters supplied by the users are correct.</p>
            </section>
        </section>
    </section>
    <section id="the-example-module">
        <h2>2   The Example module</h2>
        <p>An example module that can be used as a template is available in <a href="https://github.com/mozilla/mig/blob/master/src/mig/modules/example/example.go">src/mig/modules/example/</a>. We will study its structure to understand how modules are written and executed.</p>
        <section id="headers-and-structs">
            <h3>2.1   Headers and structs</h3>
            <p>The first part of the module takes care of the registration and declaration of needed structs.</p>
            <pre class="code go"><span class="kn">package</span> <span class="nx">example</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"encoding/json"</span>
    <span class="s">"fmt"</span>
    <span class="s">"mig/modules"</span>
    <span class="s">"net"</span>
    <span class="s">"os"</span>
    <span class="s">"regexp"</span>
<span class="p">)</span>

<span class="c1">// init is called by the Go runtime at startup. We use this function to
// register the module in a global array of available modules, so the
// agent knows we exist
</span><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">modules</span><span class="p">.</span><span class="nx">Register</span><span class="p">(</span><span class="s">"example"</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">run</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">run</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Parameters</span> <span class="nx">params</span>
    <span class="nx">Results</span>    <span class="nx">modules</span><span class="p">.</span><span class="nx">Result</span>
<span class="p">}</span>

<span class="c1">// a simple parameters structure, the format is arbitrary
</span><span class="kd">type</span> <span class="nx">params</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">GetHostname</span>  <span class="kt">bool</span>     <span class="s">`json:"gethostname"`</span>
    <span class="nx">GetAddresses</span> <span class="kt">bool</span>     <span class="s">`json:"getaddresses"`</span>
    <span class="nx">LookupHost</span>   <span class="p">[]</span><span class="kt">string</span> <span class="s">`json:"lookuphost"`</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">elements</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Hostname</span>     <span class="kt">string</span>              <span class="s">`json:"hostname,omitempty"`</span>
    <span class="nx">Addresses</span>    <span class="p">[]</span><span class="kt">string</span>            <span class="s">`json:"addresses,omitempty"`</span>
    <span class="nx">LookedUpHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span> <span class="s">`json:"lookeduphost,omitempty"`</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">statistics</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">StuffFound</span> <span class="kt">int64</span> <span class="s">`json:"stufffound"`</span>
<span class="p">}</span></pre>
            <p>Three custom structs are defined: <code>params</code>, <code>elements</code> and <code>statistics</code>.</p>
            <p><code>params</code> implements custom module parameters. In this instance, the module will access two booleans (<code>GetHostname</code> and <code>GetAddresses</code>), and one array of strings (<code>LookupHost</code>). We have decided that this module will return its hostname if <code>GetHostname</code> is set to true. It will return its IP addresses if <code>GetAddresses</code> is set to true, and it will perform DNS lookups and return the IP addresses of each FQDN listed in the <code>LookupHost</code> array.</p>
            <p><code>elements</code> will contain the results found by the module. The hostname will go into <code>elements.Hostname</code>. The local addresses will be appended into <code>elements.Addresses</code>. And each host that was looked up will be added into the <code>elements.LookedUpHost</code> map with their own arrays of IP addresses.</p>
            <p><code>statistics</code> just keeps a counter of stuffs that was found. We could also add an execution timer in this struct to indicate how look it took the module to run.</p>
        </section>
        <section id="id1">
            <h3>2.2   Validate Parameters</h3>
            <p>Next we'll implement a parameters validation function.</p>
            <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">ValidateParameters</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fqdn</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">MustCompilePOSIX</span><span class="p">(</span><span class="s">`^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$`</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">host</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">.</span><span class="nx">LookupHost</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">fqdn</span><span class="p">.</span><span class="nx">MatchString</span><span class="p">(</span><span class="nx">host</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"ValidateParameters: LookupHost parameter is not a valid FQDN."</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span></pre>
            <p>Since our parameters struct is very basic, there is little verification to do. The two booleans don't need verification, because Go is strongly typed. But we attempt to validate the FQDN of hosts that need to be looked up with a regular expression. If the validation fails, <code>ValidateParameters</code> returns an error.</p>
        </section>
        <section id="id2">
            <h3>2.3   Run</h3>
            <p>Run is what the agent will call when the module is executed. It starts by defining a panic handling routine that will transform panics into <code>modules.Result.Errors</code> and return the JSON.</p>
            <p>Then, <code>Run()</code> reads parameters from stdin. The call to <code>modules.ReadInputParameters</code> will block until one line of input is received. If what was received isn't valid parameters, it panics.</p>
            <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">Run</span><span class="p">(</span><span class="nx">in</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">out</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Errors</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span> <span class="nx">e</span><span class="p">))</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="nx">buf</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">)</span>
            <span class="nx">out</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">ReadInputParameters</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ValidateParameters</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">moduleDone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">r</span><span class="p">.</span><span class="nx">doModuleStuff</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">moduleDone</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">WatchForStop</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">stop</span><span class="p">)</span>

    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">moduleDone</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">out</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stop</span><span class="p">:</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"stop message received, terminating early"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></pre>
            <p>What happens after is a little tricky to follow. We want the module to do work, but we also want to allow the investigator to kill the module early if needed. So we first send the module to perform the work by calling <code>go r.doModuleStuff(&amp;out, &amp;moduleDone)</code> where <code>&amp;out</code> is a pointer to the string that <code>Run()</code> will return, and <code>&amp;moduleDone</code> is a channel that will receive a boolean when the module is done doing stuff.</p>
            <p>Meanwhile, we start another goroutine <code>go modules.WatchForStop(in, &amp;stop)</code> that will continously read the standard input of the module. If a <code>stop</code> message is received on the standard input, the goroutine inserts a boolean in the <code>stop</code> channel. This method is typically used by the agent to ask a module to shutdown.</p>
            <p>Both routines are running in parallel, and we use a <code>select {case}</code> to detect the first one that has activity. If the module is done, <code>Run()</code> exits normally by returning the value of <code>out</code>. But if a stop message is received, then <code>Run()</code> panics, which will generate a nicely formatted error in the defer block.</p>
        </section>
        <section id="doing-work-and-building-results">
            <h3>2.4   Doing work and building results</h3>
            <p><code>doModuleStuff</code> and <code>buildResults</code> are two module specific functions that perform the core of the module work. Their implementation is completely arbitrary. The only requirement is that the data returned is a JSON marshalled string of the struct <code>modules.Result</code>.</p>
            <p>In the sample below, the variables <code>el</code> and <code>stats</code> implement the <code>elements</code> and <code>statistics</code> types defined previously. Results are stored in these two variables, then copied into results alongside potential errors.</p>
            <p>Note in <code>buildResults</code> the way <code>FoundAnything</code> and <code>Success</code> are set to implement the rules defined earlier in this page.</p>
            <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">doModuleStuff</span><span class="p">(</span><span class="nx">out</span> <span class="o">*</span><span class="kt">string</span><span class="p">,</span> <span class="nx">moduleDone</span> <span class="o">*</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">el</span>    <span class="nx">elements</span>
        <span class="nx">stats</span> <span class="nx">statistics</span>
    <span class="p">)</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">LookedUpHost</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>

    <span class="nx">stats</span><span class="p">.</span><span class="nx">StuffFound</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// count for stuff
</span>
    <span class="c1">// grab the hostname of the endpoint
</span>    <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">.</span><span class="nx">GetHostname</span> <span class="p">{</span>
        <span class="nx">hostname</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Hostname</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">el</span><span class="p">.</span><span class="nx">Hostname</span> <span class="p">=</span> <span class="nx">hostname</span>
        <span class="nx">stats</span><span class="p">.</span><span class="nx">StuffFound</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="c1">// grab the local ip addresses
</span>    <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">.</span><span class="nx">GetAddresses</span> <span class="p">{</span>
        <span class="nx">addresses</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">InterfaceAddrs</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addresses</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="o">==</span> <span class="s">"127.0.0.1/8"</span> <span class="o">||</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="o">==</span> <span class="s">"::1/128"</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nx">el</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">,</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
            <span class="nx">stats</span><span class="p">.</span><span class="nx">StuffFound</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// look up a host
</span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">host</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Parameters</span><span class="p">.</span><span class="nx">LookupHost</span> <span class="p">{</span>
        <span class="nx">addrs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">LookupHost</span><span class="p">(</span><span class="nx">host</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">el</span><span class="p">.</span><span class="nx">LookedUpHost</span><span class="p">[</span><span class="nx">host</span><span class="p">]</span> <span class="p">=</span> <span class="nx">addrs</span>
    <span class="p">}</span>

    <span class="c1">// marshal the results into a json string
</span>    <span class="o">*</span><span class="nx">out</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buildResults</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">moduleDone</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">buildResults</span><span class="p">(</span><span class="nx">el</span> <span class="nx">elements</span><span class="p">,</span> <span class="nx">stats</span> <span class="nx">statistics</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Elements</span> <span class="p">=</span> <span class="nx">el</span>
    <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">Statistics</span> <span class="p">=</span> <span class="nx">stats</span>
    <span class="k">if</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">StuffFound</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">.</span><span class="nx">FoundAnything</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="nx">jsonOutput</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Results</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">jsonOutput</span><span class="p">[:])</span>
<span class="p">}</span></pre>
        </section>
        <section id="printing-results">
            <h3>2.5   Printing results</h3>
            <p>Printing results is needed to visualize module results efficiently. Nobody wants to read raw json, especially when querying thousands of agents at once.</p>
            <p>The function below receives a <code>modules.Result</code> struct that need to be further analyzed to access the <code>elements</code> and <code>statistics</code> types. Because these types are specific to the module, and not known to MIG, they need to be accessed using <code>result.GetElements</code> and <code>result.GetStatistics</code>.</p>
            <p>The rest of the code simply goes through the values and pretty-prints them into the <code>prints</code> array of strings.</p>
            <pre class="code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">run</span><span class="p">)</span> <span class="nx">PrintResults</span><span class="p">(</span><span class="nx">result</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="nx">matchOnly</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">prints</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">el</span>    <span class="nx">elements</span>
        <span class="nx">stats</span> <span class="nx">statistics</span>
    <span class="p">)</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">GetElements</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">el</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Hostname</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
        <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"hostname is %s"</span><span class="p">,</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Hostname</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">el</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">{</span>
        <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"address is %s"</span><span class="p">,</span> <span class="nx">addr</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">addrs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">el</span><span class="p">.</span><span class="nx">LookedUpHost</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addrs</span> <span class="p">{</span>
            <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"lookedup host %s has IP %s"</span><span class="p">,</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">addr</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">matchOnly</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
        <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"error: %v"</span><span class="p">,</span> <span class="nx">e</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">GetStatistics</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">prints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">prints</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"stat: %d stuff found"</span><span class="p">,</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">StuffFound</span><span class="p">))</span>
    <span class="k">return</span>
<span class="p">}</span></pre>
        </section>
        <section id="creating-parameters">
            <h3>2.6   Creating parameters</h3>
            <p>to be added...</p>
        </section>
    </section>
</body>
</html>