<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link href="docstyle.css" rel="stylesheet" />
    <title>Mozilla InvestiGator Concepts &amp; Internal Components</title>
    <meta content="Julien Vehent &lt;jvehent@mozilla.com&gt;" name="author" />
</head>
<body>
    <h1>Mozilla InvestiGator Concepts &amp; Internal Components</h1>
    <aside class="topic contents" id="table-of-contents">
        <h1>Table of Contents</h1>
        <ul class="auto-toc">
            <li>
                <p><a href="#actions-and-commands">1   Actions and Commands</a></p>
                <ul class="auto-toc">
                    <li><a href="#actions">1.1   Actions</a></li>
                    <li><a href="#commands">1.2   Commands</a></li>
                    <li><a href="#action-commands-workflow">1.3   Action/Commands workflow</a></li>
                </ul>
            </li>
            <li><a href="#access-control-lists">2   Access Control Lists</a></li>
            <li>
                <p><a href="#agent-initialization-process">3   Agent initialization process</a></p>
                <ul class="auto-toc">
                    <li><a href="#registration-process">3.1   Registration process</a></li>
                    <li><a href="#check-in-mode">3.2   Check-In mode</a></li>
                </ul>
            </li>
            <li><a href="#agent-upgrade-process">4   Agent upgrade process</a></li>
            <li><a href="#command-execution-flow-in-agent-and-modules">5   Command execution flow in Agent and Modules</a></li>
            <li>
                <p><a href="#threat-model">6   Threat Model</a></p>
                <ul class="auto-toc">
                    <li><a href="#strong-gpg-security-model">6.1   Strong GPG security model</a></li>
                    <li><a href="#infrastructure-resiliency">6.2   Infrastructure resiliency</a></li>
                    <li><a href="#no-port-listening">6.3   No port listening</a></li>
                    <li><a href="#protection-of-connections-to-the-relays">6.4   Protection of connections to the relays</a></li>
                    <li><a href="#randomization-of-the-queue-names">6.5   Randomization of the queue names</a></li>
                    <li><a href="#whitelisting-of-agents">6.6   Whitelisting of agents</a></li>
                    <li><a href="#limit-data-extraction-to-a-minimum">6.7   Limit data extraction to a minimum</a></li>
                </ul>
            </li>
        </ul>
    </aside>
    <p>MIG is a platform to perform investigative surgery on remote endpoints. It enables investigators to obtain information from large numbers of systems in parallel, thus accelerating investigation of incidents.</p>
    <p>Besides scalability, MIG is designed to provide strong security primitives:</p>
    <ul>
        <li><strong>Access control</strong> is ensured by requiring GPG signatures on all actions. Sensitive actions can also request signatures from multiple investigators. An attacker who takes over the central server will be able to read non-sensitive data, but will not be able to send actions to agents. The GPG keys are securely kept by their investigators.</li>
        <li><strong>Privacy</strong> is respected by never retrieving raw data from endpoints. When MIG is ran on laptops or phones, end-users can request reports on the operations performed on their devices. The 2-man-rule for sensitive actions also protect from rogue investigators invading privacy.</li>
        <li><strong>Reliability</strong> is built in. No component is critical. If an agent crashes, it will attempt to recover and reconnect to the platform indefinitely. If the platform crashes, a new platform can be rebuilt rapidly without backups.</li>
    </ul>
    <p>MIG privileges a model where requesting information from endpoints is fast and simple. It does not attempt to record everything all the time. Instead, it assumes that when an information will be needed, it will be easy to retrieve it.</p>
    <p>It's an army of Sherlock Holmes, ready to interrogate your network within milliseconds.</p>
    <p>Terminology:</p>
    <ul>
        <li><strong>Investigators</strong>: humans who use clients to investigate things on agents</li>
        <li><strong>Agent</strong>: a small program that runs on a remote endpoint. It receives commands from the scheduler through the relays, execute those commands using modules, and sends the results back to the relays.</li>
        <li><strong>Module</strong>: single feature Go program that does stuff, like inspecting a file system, listing connected IP addresses, creating user accounts or adding firewall rules</li>
        <li><strong>Scheduler</strong>: a messenging daemon that routes actions and commands to and from agents.</li>
        <li><strong>Relay</strong>: a RabbitMQ server that queues messages between schedulers and agents.</li>
        <li><strong>Database</strong>: a storage backend used by the scheduler and the api</li>
        <li><strong>API</strong>: a REST api that exposes the MIG platform to clients</li>
        <li><strong>Client</strong>: a program used by an investigator to interface with MIG (like the MIG Console, or the action generator)</li>
        <li><strong>Worker</strong>: a worker is a small extension to the scheduler and api that performs very specific tasks based on events received via the relay.</li>
    </ul>
    <p>An investigator uses a client (such as the MIG Console) to communicate with the API. The API interfaces with the Database and the Scheduler. When an action is created by an investigator, the API receives it and writes it into the spool of the scheduler (they share it via NFS). The scheduler picks it up, creates one command per target agent, and sends those commands to the relays (running RabbitMQ). Each agent is listening on its own queue on the relay. The agents execute their commands, and return the results through the same relays (same exchange, different queues). The scheduler writes the results into the database, where the investigator can access them through the API. The agents also use the relays to send heartbeat at regular intervals, such that the scheduler always knows how many agents are alive at a given time.</p>
    <p>The end-to-end workflow is:</p>
    <blockquote>
        <pre>{investigator} -https-&gt; {API} -nfs-&gt; {Scheduler} -amqps-&gt; {Relays} -amqps-&gt; {Agents}
                            \           /
                          sql\         /sql
                             {DATABASE}</pre>
    </blockquote>
    <p>Below is a high-level view of the different components:</p>
    <blockquote>
        <pre>( )               signed actions
\|/  +------+  -----------------------&gt; +-------+
 |   |client|    responses              | A P I |
/ \  +------+ &lt;-----------------------  +-----+-+       +--------+
investigator                                  +--------&gt;|  data  |
                                                        |        |
                                          action/command|--------|
                                                        |        |
                                              +--------&gt;|  base  |
                                              |         |        |
                  signed commands     +-------+---+     +--------+
                                      |           |
                  +++++--------------+| SCHEDULER |
                  |||||               |           |
                  vvvvv               +-----------+
                +-------+                  ^^^^^
                |       |                  |||||
                |message|+-----------------+++++
                |-------|     command responses
                |broker |
                |       |
                +-------+
                ^^    ^ ^
                ||    | |
   +------------+|    | +-----------------+
   |           +-+    +--+                |
   |           |         |                |
+--+--+     +--+--+    +-+---+          +-+---+
|agent|     |agent|    |agent|  .....   |agent|
+-----+     +-----+    +-----+          +-----+</pre>
    </blockquote>
    <section id="actions-and-commands">
        <h2>1   Actions and Commands</h2>
        <section id="actions">
            <h3>1.1   Actions</h3>
            <p>Actions are JSON files created by investigator to perform tasks on agents.</p>
            <p>For example, an investigator who wants to verify than root passwords are hashed and salted on linux systems, would use the following action:</p>
            <pre><code class="json"><span class="p">{</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"Compliance check for Auditd"</span><span class="p">,</span>
    <span class="nt">"description"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"author"</span><span class="p">:</span> <span class="s2">"Julien Vehent"</span><span class="p">,</span>
        <span class="nt">"email"</span><span class="p">:</span> <span class="s2">"ulfr@mozilla.com"</span><span class="p">,</span>
        <span class="nt">"url"</span><span class="p">:</span> <span class="s2">"https://some_example_url/with_details"</span><span class="p">,</span>
        <span class="nt">"revision"</span><span class="p">:</span> <span class="mi">201402071200</span>
    <span class="p">},</span>
    <span class="nt">"target"</span><span class="p">:</span> <span class="s2">"agents.environment-&gt;&gt;'ident' ILIKE '%ubuntu%' AND agents.name LIKE '%dc1.example.net'"</span><span class="p">,</span>
    <span class="nt">"threat"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"level"</span><span class="p">:</span> <span class="s2">"info"</span><span class="p">,</span>
        <span class="nt">"family"</span><span class="p">:</span> <span class="s2">"compliance"</span><span class="p">,</span>
        <span class="nt">"ref"</span><span class="p">:</span> <span class="s2">"syslowaudit1"</span>
    <span class="p">},</span>
    <span class="nt">"operations"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">"module"</span><span class="p">:</span> <span class="s2">"filechecker"</span><span class="p">,</span>
            <span class="nt">"parameters"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"/etc/shadow"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">"regex"</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">"root password strongly hashed and salted"</span><span class="p">:</span> <span class="p">[</span>
                            <span class="s2">"root:\\$(2a|5|6)\\$"</span>
                        <span class="p">]</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">"syntaxversion"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span></code></pre>
            <p>The parameters are:</p>
            <ul>
                <li><strong>name</strong>: a string that represents the action.</li>
                <li>
                    <p><strong>target</strong>: a search string used by the scheduler to find agents to run the action on. The target format uses Postgresql's WHERE condition format against the <a href="data.rst.html#entity-relationship-diagram">agents</a> table of the database. This method allows for complex target queries, like running an action against a specific operating system, or against an endpoint that has a given public IP, etc...</p>
                    <p>The most simple query that targets all agents is <cite>name like '%'</cite> (the <cite>%</cite> character is a wildcard in SQL pattern matching). Targetting by OS family can be done on the <cite>os</cite> parameters such as <cite>os='linux'</cite> or <cite>os='darwin'</cite>.</p>
                    <p>Combining conditions is also trivial: <cite>version='201409171023+c4d6f50.prod' and heartbeattime &gt; NOW() - interval '1 minute'</cite> will only target agents that run a specific version and have sent a heartbeat during the last minute.</p>
                    <p>Complex queries are also possible. For example: imagine an action with ID 1 launched against 10,000 endpoints, which returned 300 endpoints with positive results. We want to launch action 2 on those 300 endpoints only. It can be accomplished with the following <cite>target</cite> condition. (note: you can reuse this condition by simply changing the value of <cite>actionid</cite>)</p>
                </li>
            </ul>
            <pre><code class="sql"><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">select</span> <span class="n">agentid</span> <span class="k">from</span> <span class="n">commands</span><span class="p">,</span> <span class="n">json_array_elements</span><span class="p">(</span><span class="n">commands</span><span class="p">.</span><span class="n">results</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span> <span class="k">where</span> <span class="n">actionid</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="n">r</span><span class="o">#&gt;&gt;</span><span class="s1">'{foundanything}'</span> <span class="o">=</span> <span class="s1">'true'</span><span class="p">)</span></code></pre>
            <ul>
                <li><strong>description</strong> and <strong>threat</strong>: additional fields to describe the action</li>
                <li><strong>operations</strong>: an array of operations, each operation calls a module with a set of parameters. The parameters syntax are specific to the module.</li>
                <li><strong>syntaxversion</strong>: indicator of the action format used. Should be set to 2</li>
            </ul>
            <p>Upon generation, additional fields are appended to the action:</p>
            <ul>
                <li><strong>pgpsignatures</strong>: all of the parameters above are concatenated into a string and signed with the investigator's private GPG key. The signature is part of the action, and used by agents to verify that an action comes from a trusted investigator. <cite>PGPSignatures</cite> is an array that contains one or more signature from authorized investigators.</li>
                <li><strong>validfrom</strong> and <strong>expireafter</strong>: two dates that constrains the validity of the action to a UTC time window.</li>
            </ul>
            <p>Actions files are submitted to the API or the Scheduler directly. The PGP Signatures are always verified by the agents, and can optionally be verified by other components along the way. Additional attributes are added to the action by the scheduler. Those are defined in the database schema and are used to track the action status.</p>
        </section>
        <section id="commands">
            <h3>1.2   Commands</h3>
            <p>Upon processing of an Action, the scheduler will retrieve a list of agents to send the action to. One action is then derived into Commands. A command contains an action plus additional parameters that are specific to the target agent, such as command processing timestamps, name of the agent queue on the message broker, Action and Command unique IDs, status and results of the command. Below is an example of the previous action ran against the agent named 'myserver1234.test.example.net'.</p>
            <pre><code class="json"><span class="p">{</span>
    <span class="nt">"action"</span><span class="p">:</span>        <span class="p">{</span> <span class="err">...</span> <span class="err">signed</span> <span class="err">copy</span> <span class="err">of</span> <span class="err">action</span> <span class="err">...</span> <span class="p">}</span>
    <span class="s2">"agentname"</span><span class="p">:</span>     <span class="s2">"myserver1234.test.example.net"</span><span class="p">,</span>
    <span class="nt">"agentqueueloc"</span><span class="p">:</span> <span class="s2">"linux.myserver1234.test.example.net.55tjippis7s4t"</span><span class="p">,</span>
    <span class="nt">"finishtime"</span><span class="p">:</span>    <span class="s2">"2014-02-10T15:28:34.687949847Z"</span><span class="p">,</span>
    <span class="nt">"id"</span><span class="p">:</span>            <span class="mi">5978792535962156489</span><span class="p">,</span>
    <span class="nt">"results"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">"elements"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"/etc/shadow"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">"regex"</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">"root password strongly hashed and salted"</span><span class="p">:</span> <span class="p">{</span>
                            <span class="nt">"root:\\$(2a|5|6)\\$"</span><span class="p">:</span> <span class="p">{</span>
                                <span class="nt">"Filecount"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="nt">"Files"</span><span class="p">:</span> <span class="p">{},</span>
                                <span class="nt">"Matchcount"</span><span class="p">:</span> <span class="mi">0</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="nt">"extra"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"statistics"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">"checkcount"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="nt">"checksmatch"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="nt">"exectime"</span><span class="p">:</span> <span class="s2">"183.237us"</span><span class="p">,</span>
                    <span class="nt">"filescount"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="nt">"openfailed"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="nt">"totalhits"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="nt">"uniquefiles"</span><span class="p">:</span> <span class="mi">0</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="nt">"foundanything"</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">"starttime"</span><span class="p">:</span> <span class="s2">"2014-02-10T15:28:34.118926659Z"</span><span class="p">,</span>
    <span class="nt">"status"</span><span class="p">:</span> <span class="s2">"succeeded"</span>
<span class="p">}</span></code></pre>
            <p>The results of the command show that the file '/etc/shadow' has not matched, and thus "FoundAnything" returned "false. While the result is negative, the command itself has succeeded. Had a failure happened on the agent, the scheduler would have been notified and the status would be one of "failed", "timeout" or "cancelled".</p>
        </section>
        <section id="action-commands-workflow">
            <h3>1.3   Action/Commands workflow</h3>
            <p>The diagram below represents the full workflow from the launch of an action by an investigation, to the retrieval of results from the database. The steps are explained in the legend of the diagram, and map to various components of MIG.</p>
            <p>View <a href=".files/action_command_flow.svg">full size diagram</a>.</p>
            <img src=".files/action_command_flow.svg" />
        </section>
    </section>
    <section id="access-control-lists">
        <h2>2   Access Control Lists</h2>
        <p>Not all keys can perform all actions. The scheduler, for example, sometimes need to issue specific actions to agents (such as during the upgrade protocol) but shouldn't be able to perform more dangerous actions. This is enforced by an Access Control List, or ACL, stored on the agents. An ACL describes who can access what function of which module. It can be used to require multiple signatures on specific actions, and limit the list of investigators allowed to perform an action.</p>
        <p>An ACL is composed of permissions, which are JSON documents hardwired into the agent configuration. In the future, MIG will dynamically ship permissions to agents.</p>
        <p>Below is an example of a permission for the <cite>filechecker</cite> module:</p>
        <pre><code class="json"><span class="p">{</span>
    <span class="nt">"filechecker"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"minimumweight"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">"investigators"</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">"Bob Kelso"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"fingerprint"</span><span class="p">:</span> <span class="s2">"E60892BB9BD..."</span><span class="p">,</span>
                <span class="nt">"weight"</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="nt">"John Smith"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"fingerprint"</span><span class="p">:</span> <span class="s2">"9F759A1A0A3..."</span><span class="p">,</span>
                <span class="nt">"weight"</span><span class="p">:</span> <span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
        <p><cite>investigators</cite> contains a list of users with their PGP fingerprints, and their weight, an integer that represents their access level. When an agent receives an action that calls the filechecker module, it will first verify the signatures of the action, and then validates that the signers are authorized to perform the action. This is done by summing up the weights of the signatures, and verifying that they equal or exceed the minimum required weight.</p>
        <p>Thus, in the example above, investigator John Smith cannot issue a filechecker action alone. His weight of 1 doesn't satisfy the minimum weight of 2 required by the filechecker permission. Therefore, John will need to ask investigator Bob Kelso to sign his action as well. The weight of both investigators are then added, giving a total of 3, which satisfies the minimum weight of 2.</p>
        <p>This method gives ample flexibility to require multiple signatures on modules, and ensure that one investigator cannot perform sensitive actions on remote endpoints without the permissions of others.</p>
        <p>The default permission <cite>default</cite> can be used as a default for all modules. It has the following syntax:</p>
        <pre><code class="json"><span class="p">{</span>
    <span class="nt">"default"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"minimumweight"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">"investigators"</span><span class="p">:</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
        <span class="err">]</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
        <p>The <cite>default</cite> permission is overridden by module specific permissions.</p>
        <p>The ACL is currently applied to modules. In the future, ACL will have finer control to authorize access to specific functions of modules. For example, an investigator could be authorized to call the <cite>regex</cite> function of filechecker module, but only in <cite>/etc</cite>. This functionality is not implemented yet.</p>
    </section>
    <section id="agent-initialization-process">
        <h2>3   Agent initialization process</h2>
        <p>The agent tries to be as autonomous as possible. One of the goal is to ship agents without requiring external provisioning tools, such as Chef or Puppet. Therefore, the agent attempts to install itself as a service, and also supports a builtin upgrade protocol (described in the next section).</p>
        <p>As a portable binary, the agent needs to detect the type of operating system and init method that is used by an endpoint. Depending on the endpoint, different initialization methods are used. The diagram below explains the decision process followed by the agent.</p>
        <img src=".files/mig-agent-initialization-process.png" />
        <p>Go does not provide support for running programs in the backgroud. On endpoints that run upstart, systemd (linux) or launchd (darwin), this is not an issue because the init daemon takes care of running the agent in the background, rerouting its file descriptors and restarting on crash. On Windows and System-V, however, the agent daemonizes by forking itself into <cite>foreground</cite> mode, and re-forking itself on error (such as loss of connectivity to the relay). On Windows and System-V, if the agent is killed, it will not be restarted automatically.</p>
        <section id="registration-process">
            <h3>3.1   Registration process</h3>
            <p>The initialization process goes through several environment detection steps which are used to select the proper init method. Once started, the agent will send a heartbeat to the public relay, and also store that heartbeat in its <cite>run</cite> directory. The location of the <cite>run</cite> directory is platform specific.</p>
            <ul>
                <li>windows: C:Windows</li>
                <li>darwin: /Library/Preferences/mig/</li>
                <li>linux: /var/run/mig/</li>
            </ul>
            <p>Below is a sample heartbeat message from a linux agent stored in <cite>/var/run/mig/mig-agent.ok</cite>.</p>
            <pre><code class="json"><span class="p">{</span>
    <span class="nt">"destructiontime"</span><span class="p">:</span> <span class="s2">"0001-01-01T00:00:00Z"</span><span class="p">,</span>
    <span class="nt">"environment"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"arch"</span><span class="p">:</span> <span class="s2">"amd64"</span><span class="p">,</span>
        <span class="nt">"ident"</span><span class="p">:</span> <span class="s2">"Red Hat Enterprise Linux Server release 6.5 (Santiago)"</span><span class="p">,</span>
        <span class="nt">"init"</span><span class="p">:</span> <span class="s2">"upstart"</span>
    <span class="p">},</span>
    <span class="nt">"heartbeatts"</span><span class="p">:</span> <span class="s2">"2014-07-31T14:00:20.00442837-07:00"</span><span class="p">,</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"someserver.example.net"</span><span class="p">,</span>
    <span class="nt">"os"</span><span class="p">:</span> <span class="s2">"linux"</span><span class="p">,</span>
    <span class="nt">"pid"</span><span class="p">:</span> <span class="mi">26256</span><span class="p">,</span>
    <span class="nt">"queueloc"</span><span class="p">:</span> <span class="s2">"linux.someserver.example.net.5hsa811oda"</span><span class="p">,</span>
    <span class="nt">"starttime"</span><span class="p">:</span> <span class="s2">"2014-07-30T21:34:48.525449401-07:00"</span><span class="p">,</span>
    <span class="nt">"version"</span><span class="p">:</span> <span class="s2">"201407310027+bcbdd94.prod"</span>
<span class="p">}</span></code></pre>
        </section>
        <section id="check-in-mode">
            <h3>3.2   Check-In mode</h3>
            <p>In infrastructure where running the agent as a permanent process is not acceptable, it is possible to run the agent as a cron job. By starting the agent with the flag <strong>-m agent-checkin</strong>, the agent will connect to the configured relay, retrieve and run outstanding commands, and exit after 10 seconds of inactivity.</p>
        </section>
    </section>
    <section id="agent-upgrade-process">
        <h2>4   Agent upgrade process</h2>
        <p>MIG supports upgrading agents in the wild. The upgrade protocol is designed with security in mind. The flow diagram below presents a high-level view:</p>
        <blockquote>
            <pre>Investigator          Scheduler             Agent             NewAgent           FileServer
+-----------+         +-------+             +---+             +------+           +--------+
      |                   |                   |                   |                   |
      |    1.initiate     |                   |                   |                   |
      |------------------&gt;|                   |                   |                   |
      |                   |  2.send command   |                   |                   |
      |                   |------------------&gt;| 3.verify          |                   |
      |                   |                   |--------+          |                   |
      |                   |                   |        |          |                   |
      |                   |                   |        |          |                   |
      |                   |                   |&lt;-------+          |                   |
      |                   |                   |                   |                   |
      |                   |                   |    4.download     |                   |
      |                   |                   |--------------------------------------&gt;|
      |                   |                   |                   |                   |
      |                   |                   | 5.checksum        |                   |
      |                   |                   |--------+          |                   |
      |                   |                   |        |          |                   |
      |                   |                   |        |          |                   |
      |                   |                   |&lt;-------+          |                   |
      |                   |                   |                   |                   |
      |                   |                   |      6.exec       |                   |
      |                   |                   |------------------&gt;|                   |
      |                   |  7.return own PID |                   |                   |
      |                   |&lt;------------------|                   |                   |
      |                   |                   |                   |                   |
      |                   |------+ 8.mark     |                   |                   |
      |                   |      | agent as   |                   |                   |
      |                   |      | upgraded   |                   |                   |
      |                   |&lt;-----+            |                   |                   |
      |                   |                   |                   |                   |
      |                   |    9.register     |                   |                   |
      |                   |&lt;--------------------------------------|                   |
      |                   |                   |                   |                   |
      |                   |------+10.find dup |                   |                   |
      |                   |      |agents in   |                   |                   |
      |                   |      |registrations                   |                   |
      |                   |&lt;-----+            |                   |                   |
      |                   |                   |                   |                   |
      |                   |    11.send command to kill PID old agt|                   |
      |                   |--------------------------------------&gt;|                   |
      |                   |                   |                   |                   |
      |                   |  12.acknowledge   |                   |                   |
      |                   |&lt;--------------------------------------|                   |</pre>
        </blockquote>
        <p>All upgrade operations are initiated by an investigator (1). The upgrade is triggered by an action to the upgrade module with the following parameters:</p>
        <pre><code class="json"><span class="s2">"Operations"</span><span class="err">:</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="nt">"Module"</span><span class="p">:</span> <span class="s2">"upgrade"</span><span class="p">,</span>
        <span class="nt">"Parameters"</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">"linux/amd64"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"to_version"</span><span class="p">:</span> <span class="s2">"16eb58b-201404021544"</span><span class="p">,</span>
                <span class="nt">"location"</span><span class="p">:</span> <span class="s2">"http://localhost/mig/bin/linux/amd64/mig-agent"</span><span class="p">,</span>
                <span class="nt">"checksum"</span><span class="p">:</span> <span class="s2">"31fccc576635a29e0a27bbf7416d4f32a0ebaee892475e14708641c0a3620b03"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">]</span><span class="err">,</span></code></pre>
        <ul>
            <li>Each OS family and architecture have their own parameters (ex: "linux/amd64", "darwin/amd64", "windows/386", ...). Then, in each OS/Arch group, we have:</li>
            <li>to_version is the version an agent should upgrade to</li>
            <li>location points to a HTTPS address that contains the agent binary</li>
            <li>checksum is a SHA256 hash of the agent binary to be verified after download</li>
        </ul>
        <p>The parameters above are signed using a standard PGP action signature.</p>
        <p>The upgrade action is forwarded to agents (2) like any other action. The action signature is verified by the agent (3), and the upgrade module is called. The module downloads the new binary (4), verifies the version and checksum (5) and installs itself on the system.</p>
        <p>Assuming everything checks in, the old agent executes the binary of the new agent (6). At that point, two agents are running on the same machine, and the rest of the protocol is designed to shut down the old agent, and clean up.</p>
        <p>After executing the new agent, the old agent returns a successful result to the scheduler, and includes its own PID in the results. The new agent starts by registering with the scheduler (7). This tells the scheduler that two agents are running on the same node, and one of them must terminate. The scheduler sends a kill action to both agents with the PID of the old agent (8). The kill action may be executed twice, but that doesn't matter. When the scheduler receives the kill results (9), it sends a new action to check for <cite>mig-agent</cite> processes (10). Only one should be found in the results (11), and if that is the case, the scheduler tells the agent to remove the binary of the old agent (12). When the agent returns (13), the upgrade protocol is done.</p>
        <p>If the PID of the old agent lingers on the system, an error is logged for the investigator to decide what to do next. The scheduler does not attempt to clean up the situation.</p>
    </section>
    <section id="command-execution-flow-in-agent-and-modules">
        <h2>5   Command execution flow in Agent and Modules</h2>
        <p>An agent receives a command from the scheduler on its personal AMQP queue (1). It parses the command (2) and extracts all of the operations to perform. Operations are passed to modules and executed asynchronously (3). Rather than maintaining a state of the running command, the agent create a goroutine and a channel tasked with receiving the results from the modules. Each modules published its results inside that channel (4). The result parsing goroutine receives them, and when it has received all of them, builds a response (5) that is sent back to the scheduler(6).</p>
        <p>When the agent is done running the command, both the channel and the goroutine are destroyed.</p>
        <blockquote>
            <pre>         +-------+   [ - - - - - - A G E N T - - - - - - - - - - - - ]
         |command|+----&gt;(listener)
         +-------+          |(2)
           ^                V
           |(1)         (parser)
           |               +       [ m o d u l e s ]
+-----+    |            (3)|----------&gt; op1 +----------------+
|SCHED|+---+               |------------&gt; op2 +--------------|
| ULER|&lt;---+               |--------------&gt; op3 +------------|
+-----+    |               +----------------&gt; op4 +----------+
           |                                                 V(4)
           |(6)                                         (receiver)
           |                                                 |
           |                                                 V(5)
           +                                             (publisher)
         +-------+                                           /
         |results|&lt;-----------------------------------------'
         +-------+</pre>
        </blockquote>
    </section>
    <section id="threat-model">
        <h2>6   Threat Model</h2>
        <p>Running an agent as root on a large number of endpoints means that Mozilla InvestiGator is a target of choice to compromise an infrastructure. Without proper protections, a vulnerability in the agent or in the platform could lead to a compromission of the endpoints.</p>
        <p>The architectural choices made in MIG diminish the exposure of the endpoints to a compromise. And while the risk cannot be reduced to zero entirely, it would take an attacker direct control on the investigators key material, or be root on the infrastructure in order to take control of MIG.</p>
        <p>MIG's security controls include:</p>
        <ul>
            <li>Strong GPG security model</li>
            <li>Infrastructure resiliency</li>
            <li>No port listening</li>
            <li>Protection of connections to the relays</li>
            <li>Randomization of the queue names</li>
            <li>Whitelisting of agents</li>
            <li>Limit data extraction to a minimum</li>
        </ul>
        <section id="strong-gpg-security-model">
            <h3>6.1   Strong GPG security model</h3>
            <p>All actions that are passed to the MIG platform and to the agents require valid GPG signatures from one or more trusted investigators. The public keys of trusted investigators are hardcoded in the agents, making it almost impossible to override without root access to the endpoints, or access to an investigator's private key. The GPG private keys are never seen by the MIG platform (API, Scheduler, Database or Relays). A compromise of the platform would not lead to an attacker taking control of the agents and compromising the endpoints.</p>
        </section>
        <section id="infrastructure-resiliency">
            <h3>6.2   Infrastructure resiliency</h3>
            <p>One of the design goal of MIG is to make each components as stateless as possible. The database is used as a primary data store, and the schedulers and relays keep data in transit in their respective cache. But any of these components can go down and be rebuilt without compromising the resiliency of the platform. As a matter of fact, it is strongly recommended to rebuilt each of the platform component from scratch on a regular basis, and only keep the database as a persistent storage.</p>
            <p>Unlike other systems that require constant network connectivity between the agents and the platform, MIG is designed to work with intermittent or unreliable connectivity with the agents. The rabbitmq relays will cache commands that are not consumed immediately by offline agents. These agents can connect to the relay whenever they chose to, and pick up outstanding tasks.</p>
            <p>If the relays go down for any period of time, the agents will attempt to reconnect at regular intervals continuously. It is trivial to rebuild a fresh rabbitmq cluster, even on a new IP space, as long as the FQDN of the cluster, and the TLS cert/key and credentials of the AMQPS access point remain the same.</p>
        </section>
        <section id="no-port-listening">
            <h3>6.3   No port listening</h3>
            <p>The agents do not accept incoming connections. There is no listening port that an attacker could use to exploit a vulnerability in the agent. Instead, the agent connects to the platform by establishing an outbound connection to the relays. The connection uses TLS, making it theorically impossible for an attacker to MITM without access to the PKI and DNS, both of which are not part of the MIG platform.</p>
        </section>
        <section id="protection-of-connections-to-the-relays">
            <h3>6.4   Protection of connections to the relays</h3>
            <p>The rabbitmq relay of a MIG infrastructure may very well be listening on the public internet. This is used when MIG agents are distributed into various environments, as opposed to concentrated on a single network location. RabbitMQ and Erlang provide a stable network stack, but are not shielded from a network attack that would take down the cluster. To reduce the exposure of the AMQP endpoints, the relays use AMQP over TLS and require the agents to present a client certificate before accepting the connection.</p>
            <p>The client certificate is shared across all the agents. <strong>It is not used as an authentication mechanism.</strong> Its sole purpose is to limit the exposure of a public AMQP endpoint. Consider it a network filter.</p>
            <p>Once the TLS connection between the agent and the relay is established, the agent will present a username and password to open the AMQP connection. Again, these credentials are shared across all agents, and are not used to authenticate individual agents. Their role is to assign an ACL to the agent. The ACL limits the AMQP action an agent can perform on the cluster. See <a href="configuration.rst">rabbitmq configuration</a> for more information.</p>
        </section>
        <section id="randomization-of-the-queue-names">
            <h3>6.5   Randomization of the queue names</h3>
            <p>The protections above limit the exposure of the AMQP endpoint, but since the secrets are shared across all agents, the possibility still exists that an attacker gains access to the secrets, and establish a connection to the relays.</p>
            <p>Such access would have very limited capabilities. It cannot be used to publish commands to the agents, because publication is ACL-limited to the scheduler. It can be used to publish fake results to the scheduler, or listen on the agent queue for incoming commands.</p>
            <p>Both are made difficult by prepending a random number to the name of an agent queue. An agent queue is named using the following scheme:</p>
            <blockquote>
                <p><cite>mig.agt.&lt;OS family&gt;.&lt;Hostname&gt;.&lt;uid&gt;</cite></p>
            </blockquote>
            <p>The OS and hostname of a given agent are easy to guess, but the uid isn't. The UID is a 64 bits integer composed of nanosecond timestamps and a random 32 bits integer, chosen by the agent on first start. It is specific to an endpoint.</p>
        </section>
        <section id="whitelisting-of-agents">
            <h3>6.6   Whitelisting of agents</h3>
            <p>At the moment, MIG does not provide a strong mechanism to authenticate agents. It is a work in progress, but for now agents are whitelisted in the scheduler using the queuelocs that are advertised in the heartbeat messages. Spoofing the queueloc string is difficult, because it contains a random value that is specific to an endpoint. An attacker would need access to the random value in order to spoof an agent's identity. This method provides a basic access control mechanism. The long term goal is to allow the scheduler to call an external database to authorize agents. In AWS, the scheduler could call the AWS API to verify that a given agent does indeed exist in the infrastructure. In a traditional datacenter, this could be an inventory database.</p>
        </section>
        <section id="limit-data-extraction-to-a-minimum">
            <h3>6.7   Limit data extraction to a minimum</h3>
            <p>Agents are not <cite>meant</cite> to retrieve raw data from their endpoints. This is more of a good practice rather than a technical limitation. The modules shipped with the agent are meant to return boolean answers of the type "match" or "no match".</p>
            <p>It could be argued that answering "match" on sensitive requests is similar to extracting data from the agents. MIG does not solve this issue.. It is the responsibility of the investigators to limit the scope of their queries (ie, do not search for a root password by sending an action with the password in the regex).</p>
            <p>The goal here is to prevent a rogue investigator from dumping large amount of data from an endpoint. MIG could trigger a memory dump of a process, but retrieve that data will require direct access to the endpoint.</p>
            <p>Note that MIG's database keeps records of all actions, commands and results. If sensitive data were to be collected by MIG, that data would be available in the database.</p>
        </section>
    </section>
</body>
</html>